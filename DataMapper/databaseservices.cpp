#include "databaseservices.h"
#include <QtCore/QUuid>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>
#include <exception>
#include <boost/uuid/uuid_io.hpp>
#include "datatransform.h"

DatabaseServices::DatabaseServices()
{
}


DatabaseServices::~DatabaseServices()
{
}

bool DatabaseServices::IsSQLiteDB(const QString& filename) {

	const char* first16BytesOfSQLiteDB = "SQLite format 3";

	QFile file(filename);
	if (file.exists()) {
		
		if (file.open(QIODevice::ReadOnly)) {
			
			uchar* first16bytes = file.map(0, 16);
			file.close();

			return (memcmp(first16bytes, first16BytesOfSQLiteDB, 16) == 0);
		}
	}

	return false;
}

QString DatabaseServices::GetFormattedDBName(const QSqlDatabase& db) {

	QString databaseName = db.databaseName();

	if (db.driverName() == "QSQLITE") {
		QFileInfo fi(databaseName);
		return fi.baseName();
	}
	else {
		return databaseName;
	}
}

QString DatabaseServices::GetFormattedDBName(const boost::uuids::uuid& databaseID) {

	QSqlDatabase db = QSqlDatabase::database(QString::fromStdString(boost::uuids::to_string(databaseID)));
	return GetFormattedDBName(db);
}

void DatabaseServices::RemoveAutoGeneratedTableNamesFromList(QStringList& list) {

	list.removeAll("sqlite_sequence");
}

QString DatabaseServices::GetQtDBType(SynGlyphX::Datasource::SourceType sourceType) {

	if (sourceType == SynGlyphX::Datasource::SQLITE3) {
		return "QSQLITE";
	}

	return "";
}

void DatabaseServices::AddDatabaseConnections(const SynGlyphX::DataTransform::DatasourceMap& datasources, unsigned int numNewDatasources) {

	SynGlyphX::DataTransform::DatasourceMap::const_iterator iT = datasources.begin();
	std::advance(iT, datasources.size() - numNewDatasources);
	for (; iT != datasources.end(); ++iT) {

		QSqlDatabase newDataSourceDB = QSqlDatabase::addDatabase(GetQtDBType(iT->second.GetType()), QString::fromStdString(boost::uuids::to_string(iT->first)));
		newDataSourceDB.setDatabaseName(QString::fromStdWString(iT->second.GetDBName()));
	}
}