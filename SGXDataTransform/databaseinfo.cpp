#include "databaseinfo.h"
#include <QtCore/QFile>

namespace SynGlyphX {

	DatabaseInfo::DatabaseInfo()
	{
	}


	DatabaseInfo::~DatabaseInfo()
	{
	}

	bool DatabaseInfo::IsSQLiteDB(const QString& filename) {

		const char* first16BytesOfSQLiteDB = "SQLite format 3";

		QFile file(filename);
		if (file.exists()) {

			if (file.open(QIODevice::ReadOnly)) {

				uchar* first16bytes = file.map(0, 16);
				file.close();

				return (memcmp(first16bytes, first16BytesOfSQLiteDB, 16) == 0);
			}
		}

		return false;
	}

	QStringList DatabaseInfo::GetListOfTablesWithoutAutogeneratedTables(const QSqlDatabase& db) {

		QStringList tableList = db.tables(QSql::Tables);
		tableList.append(db.tables(QSql::Views));

		if (db.driverName() == "QSQLITE") {

			tableList.removeAll("sqlite_sequence");
		}

		return tableList;
	}

	QStringList DatabaseInfo::GetListOfTablesWithoutAutogeneratedTablesInDatabaseFile(const QString& dbName) {

		QStringList tables;
		if (IsSQLiteDB(dbName)) {

			QSqlDatabase newDataSourceDB = QSqlDatabase::addDatabase("QSQLITE", "TEMPDB");
			newDataSourceDB.setDatabaseName(dbName);

			newDataSourceDB.open();
			tables = GetListOfTablesWithoutAutogeneratedTables(newDataSourceDB);

			newDataSourceDB.close();
			QSqlDatabase::removeDatabase("TEMPDB");
		}
		else {

			throw std::invalid_argument("File is not a SQLite database.");
		}

		return tables;
	}

	QStringList DatabaseInfo::GetSQLiteDataTypesForFormat(const QString& format) {

		QStringList fieldTypes;
		if (format.toUpper() == "CSV") {

			fieldTypes.push_back("Text");
			fieldTypes.push_back("Integer");
			fieldTypes.push_back("Real");
		}
		else {

			throw std::invalid_argument("Format " + format.toStdString() + " was not recognized");
		}

		return fieldTypes;
	}

} //namespace SynGlyphX