#include "sourcedatacache.h"
#include <QtSql/QSqlRecord>
#include <QtSql/QSqlQuery>
#include <QtSql/QSqlField>
#include <QtSql/QSqlError>
#include <QtCore/QVariant>
#include <QtCore/QDateTime>
#include <QtCore/QFileInfo>
#include <boost/uuid/uuid_io.hpp>
#include "uuid.h"
#include "databaseinfo.h"

namespace SynGlyphX {

	const QString SourceDataCache::IndexColumnName = "rowid";

	SourceDataCache::SourceDataCache() :
		CSVCache() {

	}

	SourceDataCache::SourceDataCache(const QString& filename) :
		CSVCache()
	{
		Setup(filename);
	}

	SourceDataCache::~SourceDataCache()
	{
		
	}

	bool SourceDataCache::IsValid() const {

		return CSVCache::IsValid();
	}

	void SourceDataCache::Close() {

		CSVCache::Close();
		m_tableIndexMap.clear();
		m_tableNameMap.clear();
	}

	void SourceDataCache::Setup(const QString& filename) {

		CSVCache::Setup(filename);
		RebuildTableMap();
	}

	void SourceDataCache::RebuildTableMap() {

		m_tableIndexMap.clear();
		m_tableNameMap.clear();
		QStringList unorderedTables = DatabaseInfo::GetListOfTablesWithoutAutogeneratedTables(m_db);
		unorderedTables.removeAll(s_tableIndexName);
		Q_FOREACH(QString table, unorderedTables)  {

			AddTableToMap(table, GetFormattedNameFromCache(table));
		}
	}

	void SourceDataCache::AddDatasourcesToCache(const DatasourceMaps& datasources) {

		if (!IsValid()) {

			throw std::exception("Source data cache is not setup.");
		}

		for (auto fileDatasource : datasources.GetFileDatasources()) {

			AddFileDatasourceToCache(fileDatasource.first, fileDatasource.second);
		}
	}

	void SourceDataCache::AddFileDatasourceToCache(const boost::uuids::uuid& id, const FileDatasource& datasource) {
		
		try {

			if (!datasource.RequiresConversionToDB()) {

				if (DoesFileDatabaseNeedUpdate(id, datasource)) {

					DeleteTables(id);
					AddDBTablesToCache(id, datasource, "QSQLITE");
				}
			}
			else if (datasource.GetType() == FileDatasource::CSV) {

				QString newTableName = QString::fromStdString(boost::uuids::to_string(id));
				QString csvFilename = QString::fromStdWString(datasource.GetFilename());
				if (DoesCSVFileNeedUpdate(newTableName, csvFilename, GetCSVTFilename(csvFilename))) {

					QString formattedName = QString::fromStdWString(datasource.GetFormattedName());
					UpdateCSVFile(newTableName, csvFilename, formattedName);
					try {

						AddTableToMap(newTableName, formattedName);
					}
					catch (const std::exception& e) {

						throw;
					}
				}
			}
			else {

				throw std::exception("File datasource not supported");
			}
		}
		catch (const std::exception& e) {

			throw;
		}
	}

	void SourceDataCache::AddDBTablesToCache(const boost::uuids::uuid& id, const Datasource& datasource, const QString& dbType) {

		try {

			bool closeDatasource = false;
			QString dbConnectionID = QString::fromStdWString(boost::uuids::to_wstring(id));
			QSqlDatabase db;

			if (QSqlDatabase::contains(dbConnectionID)) {

				db = QSqlDatabase::database(dbConnectionID);
			}
			else {

				db = QSqlDatabase::addDatabase(dbType, dbConnectionID);
				db.setDatabaseName(QString::fromStdWString(datasource.GetDBName()));
				if (!db.open()) {

					throw std::exception("File source data source db failed to open.");
				}
				closeDatasource = true;
			}

			QString formattedName = QString::fromStdWString(datasource.GetFormattedName());
			for (const std::wstring& table : datasource.GetTables()) {

				QString qTable = QString::fromStdWString(table);
				AddDBTableToCache(db, qTable, formattedName, CreateTablename(dbConnectionID, qTable));
			}

			if (closeDatasource) {

				db.close();
				QSqlDatabase::removeDatabase(dbConnectionID);
			}
		}
		catch (const std::exception& e) {

			throw;
		}
	}

	void SourceDataCache::AddDBTableToCache(QSqlDatabase& db, const QString& sourceTable, const QString& formattedSourceName, const QString& cacheTable) {

		QString fieldNamesAndTypes;
		QString fieldNameList;
		unsigned int validFieldCount = 0;

		QSqlRecord sourceTableFieldNames = db.record(sourceTable);
		std::vector<bool> isTextField;
		isTextField.reserve(sourceTableFieldNames.count());
		for (int i = 0; i < sourceTableFieldNames.count(); ++i) {

			QString typeString;
			QSqlField field = sourceTableFieldNames.field(i);
			QVariant::Type fieldType = field.type();
			if ((fieldType == QVariant::Type::Char) || (fieldType == QVariant::Type::String) || (fieldType == QVariant::Type::Url)) {
				
				typeString = "TEXT";
			}
			else if (fieldType == QVariant::Type::Double) {
				
				typeString = "REAL";
			}
			else if ((fieldType == QVariant::Type::Int) || (fieldType == QVariant::Type::UInt) || (fieldType == QVariant::Type::LongLong) || (fieldType == QVariant::Type::ULongLong)) {
				
				typeString = "INTEGER";
			}
			else if ((fieldType == QVariant::Type::Date) || (fieldType == QVariant::Type::DateTime) || (fieldType == QVariant::Type::Time)) {
				
				typeString = "TEXT"; //Need to deal with DateTime types properly later
			}
			else {

				continue;
			}

			isTextField.push_back(typeString == "TEXT");
			fieldNameList += "\"" + field.name() + "\", ";
			fieldNamesAndTypes += "\"" + field.name() + "\" " + typeString + ",\n";
			++validFieldCount;
		}
		fieldNameList.chop(2);
		fieldNamesAndTypes.chop(2);

		if (validFieldCount == 0) {

			return;
		}

		CreateNewCacheTable(cacheTable, fieldNamesAndTypes);

		QSqlQuery getDataQuery(db);
		getDataQuery.prepare("SELECT " + fieldNameList + " FROM \"" + sourceTable + "\"");
		if (!getDataQuery.exec()) {

			throw std::exception((QObject::tr("Failed to extract source data: ") + m_db.lastError().text()).toStdString().c_str());
		}

		std::vector<QVariantList> dataToInsert;
		dataToInsert.resize(validFieldCount);

		while (getDataQuery.next()) {

			for (int k = 0; k < validFieldCount; ++k) {

				dataToInsert[k].push_back(getDataQuery.value(k));
			}
		}
		getDataQuery.finish();

		BatchInsertIntoTable(cacheTable, fieldNameList, dataToInsert);

		QString formattedTableName = CreateTablename(formattedSourceName, sourceTable);
		UpdateTimestampForTable(cacheTable, formattedTableName, QDateTime::currentDateTimeUtc());
		AddTableToMap(cacheTable, formattedTableName);
	}

	const SourceDataCache::TableIndexMap& SourceDataCache::GetTablesIndexMap() const {

		return m_tableIndexMap;
	}

	TableColumns SourceDataCache::GetColumnsForTable(const QString& table) const {

		TableColumns columnNames;
		QSqlRecord columns = m_db.record(table);
		columnNames.reserve(columns.count());
		for (int i = 0; i < columns.count(); ++i) {

			QString fieldName = columns.fieldName(i);
			if (fieldName != IndexColumnName) {

				columnNames.insert(columnNames.end(), fieldName);
			}
		}

		if (columnNames.empty()) {

			throw std::invalid_argument("Source Data Cache was asked for column names for a table that does not exist");
		}

		return columnNames;
	}

	TableColumns SourceDataCache::GetColumnsForTable(const boost::uuids::uuid& datasourceID, const QString& originalTablename) const {

		QString tableName = CreateTablename(QString::fromStdString(boost::uuids::to_string(datasourceID)), originalTablename);
		return GetColumnsForTable(tableName);
	}

	bool SourceDataCache::IsTableInCache(const boost::uuids::uuid& datasourceID, const QString& originalTablename) const {

		QString tableName = CreateTablename(QString::fromStdString(boost::uuids::to_string(datasourceID)), originalTablename);
		return (m_tableNameMap.count(tableName) != 0);
	}

	int SourceDataCache::GetLastIndexOfTable(const QString& tableName) {

		QSqlQuery query(m_db);
		query.prepare("SELECT \"" + IndexColumnName + "\" FROM \"" + tableName + "\" ORDER BY \"" + IndexColumnName + "\" DESC LIMIT 1");
		if (query.exec()) {

			query.first();
			return query.value(0).toInt() - 1;
		}
		else {

			throw std::exception((QObject::tr("Table indexing failure: ") + m_db.lastError().text()).toStdString().c_str());
		}
	}

	void SourceDataCache::CreateNewCacheTable(const QString& name, const QString& fieldNamesAndTypes) {

		CSVCache::CreateNewCacheTable(name, fieldNamesAndTypes);
	}

	void SourceDataCache::AddTableToMap(const QString& tableName, const QString& formattedName) {

		unsigned int startingIndex = 0;
		if (!m_tableIndexMap.empty()) {

			startingIndex = m_tableIndexMap.rbegin()->left + 1;
		}

		m_tableIndexMap.insert({ startingIndex + GetLastIndexOfTable(tableName), tableName });
		m_tableNameMap[tableName] = formattedName;
	}

	SharedSQLQuery SourceDataCache::CreateSelectFieldQueryAscending(const InputField& inputfield) const {

		if (!IsInputfieldInCache(inputfield)) {

			throw std::invalid_argument("Can not create SQL query for input field that isn't in the source data cache");
		}

		SharedSQLQuery query(new QSqlQuery(m_db));
		query->prepare("SELECT \"" + QString::fromStdWString(inputfield.GetField()) + "\" FROM \"" + CreateTablename(inputfield) + "\" ORDER BY \"" + IndexColumnName + "\" ASC");
		return query;
	}

	QString SourceDataCache::CreateTablename(const InputField& inputfield) {

		return CreateTablename(QString::fromStdString(boost::uuids::to_string(inputfield.GetDatasourceID())), QString::fromStdWString(inputfield.GetTable()));
	}
		
	QString SourceDataCache::CreateTablename(const QString& datasourceID, const QString& originalTablename) {

		if ((originalTablename.isEmpty()) || (originalTablename.toStdWString() == SynGlyphX::Datasource::SingleTableName)) {

			return datasourceID;
		}
		else {

			return datasourceID + ":" + originalTablename;
		}
	}

	SharedSQLQuery SourceDataCache::CreateMinMaxQuery(const InputField& inputfield) const {

		if (!IsInputfieldInCache(inputfield)) {

			throw std::invalid_argument("Can not create SQL query for input field that isn't in the source data cache");
		}

		SharedSQLQuery query(new QSqlQuery(m_db));
		QString queryString = QString("SELECT MIN(%1), MAX(%1) FROM ").arg("\"" + QString::fromStdWString(inputfield.GetField()) + "\"") + "\"" + CreateTablename(inputfield) + "\"";
		query->prepare(queryString);

		return query;
	}

	bool SourceDataCache::IsInputfieldInCache(const InputField& inputfield) const {

		QString inputFieldTable = QString::fromStdWString(boost::uuids::to_wstring(inputfield.GetDatasourceID()));
		if ((!inputfield.GetTable().empty()) && (inputfield.GetTable() != SynGlyphX::Datasource::SingleTableName)) {

			inputFieldTable += ":" + QString::fromStdWString(inputfield.GetTable());
		}

		return (m_tableIndexMap.right.count(inputFieldTable) > 0);
	}

	void SourceDataCache::DeleteTable(const QString& table) {

		CSVCache::DeleteTable(table);
		RebuildTableMap();
	}

	void SourceDataCache::DeleteTables(const QStringList& tables) {

		if (tables.isEmpty()) {

			return;
		}

		Q_FOREACH(const QString& table, tables) {

			CSVCache::DeleteTable(table);
		}
		RebuildTableMap();
	}

	void SourceDataCache::DeleteTables(const boost::uuids::uuid& id) {

		QString datasourceId = QString::fromStdString(boost::uuids::to_string(id));
		QStringList tablesToDelete;
		for (auto table : m_tableNameMap) {

			if (table.first.startsWith(datasourceId)) {

				tablesToDelete.push_back(table.first);
			}
		}
		DeleteTables(tablesToDelete);
	}

	const SourceDataCache::TableNameMap& SourceDataCache::GetFormattedNames() const {

		return m_tableNameMap;
	}

	QString SourceDataCache::GetFormattedNameFromCache(const QString& table) {

		QSqlQuery query(m_db);
		query.prepare("SELECT \"FormattedName\" FROM \"" + s_tableIndexName + "\" WHERE \"TableName\"=\"" + table + "\"");
		if (query.exec()) {

			query.first();
			return query.value(0).toString();
		}
		else {

			throw std::exception((QObject::tr("Failure to get formatted name from cache: ") + m_db.lastError().text()).toStdString().c_str());
		}
	}

	SourceDataCache::IndexSetMap SourceDataCache::SplitIndexSet(const IndexSet& indexSet) const {

		IndexSet::const_iterator iT = indexSet.begin();
		unsigned int sizeOfPreviousTables = 0;

		IndexSetMap indexSets;
		for (auto table : m_tableIndexMap) {

			std::set<unsigned long> indexSetForTable;
			while ((iT != indexSet.end()) && (*iT <= table.left)) {

				indexSetForTable.insert(*iT - sizeOfPreviousTables);
				++iT;
			}

			if (!indexSetForTable.empty()) {

				indexSets[table.right] = indexSetForTable;
			}

			sizeOfPreviousTables += table.left + 1;
		}

		return indexSets;
	}

	SharedSQLQuery SourceDataCache::CreateSelectQueryForIndexSet(const QString& tableName, const TableColumns& columns, const IndexSet& indexSet) const {

		TableColumns::const_iterator column = columns.begin();
		QString columnNameString = "\"" + *column;
		++column;
		for (; column != columns.end(); ++column) {

			columnNameString += "\", \"" + *column;
		}
		columnNameString += "\"";

		QString queryString = "SELECT " + columnNameString + " FROM \"" + tableName + "\" " + CreateWhereString(indexSet);

		SharedSQLQuery query(new QSqlQuery(m_db));
		query->prepare(queryString);

		return query;
	}

	SharedSQLQuery SourceDataCache::CreateDistinctValueQuery(const QString& tableName, const QString& columnName, const IndexSet& indexSet) const {

		QString queryString = "SELECT DISTINCT \"" + columnName + "\" FROM \"" + tableName + "\" ";

		if (!indexSet.empty()) {

			queryString += CreateWhereString(indexSet);
		}

		SharedSQLQuery query(new QSqlQuery(m_db));
		query->prepare(queryString);

		return query;
	}

	SharedSQLQuery SourceDataCache::CreateDistinctValueAndCountQuery(const QString& tableName, const QString& columnName, const IndexSet& indexSet) const {

		QString queryString = "SELECT \"" + columnName + "\", COUNT(*) FROM \"" + tableName + "\" ";

		if (!indexSet.empty()) {

			queryString += CreateWhereString(indexSet) + " ";
		}

		queryString += "GROUP BY \"" + columnName + "\" ";

		SharedSQLQuery query(new QSqlQuery(m_db));
		query->prepare(queryString);

		return query;
	}

	unsigned long SourceDataCache::GetValueCount(const QString& tableName, const QString& columnName, const QString& value, const IndexSet& indexSet) const {

		QString queryString = "SELECT COUNT(*) FROM \"" + tableName + "\" ";

		if (!indexSet.empty()) {

			queryString += CreateWhereString(indexSet) + " AND ";
		}
		else {

			queryString += " WHERE ";
		}

		queryString += "\"" + columnName + "\"=\"" + value + "\"";

		QSqlQuery query(m_db);
		query.prepare(queryString);
		query.exec();
		query.first();

		return query.value(0).toULongLong();
	}

	QString SourceDataCache::CreateWhereString(const IndexSet& indexSet) const {

		return "WHERE " + CreateInString(indexSet);
	}

	QString SourceDataCache::CreateInString(const IndexSet& indexSet) const {

		IndexSet::const_iterator iT = indexSet.begin();
		QString whereString = "\"" + IndexColumnName + "\" IN (" + QString::number(*iT + 1);
		++iT;
		while (iT != indexSet.end()) {

			whereString += ", " + QString::number(*iT + 1);
			++iT;
		}
		whereString += ")";

		return whereString;
	}

	QString SourceDataCache::CreateInString(const QString& columnName, const std::set<QString>& values) const {

		std::set<QString>::const_iterator iT = values.begin();
		QString inString = "\"" + columnName + "\" IN (\"" + *iT + "\"";
		++iT;
		while (iT != values.end()) {

			inString += ", \"" + *iT + "\"";
			++iT;
		}

		inString += ")";

		return inString;
	}

	unsigned long SourceDataCache::GetStartingValueForTable(const QString& tableName) const {

		auto tableIndex = m_tableIndexMap.right.find(tableName);
		if (tableIndex == m_tableIndexMap.right.begin()) {

			return 0;
		}
		else {

			tableIndex--;
			return tableIndex->get_left() + 1;
		}
	}

	IndexSet SourceDataCache::GetIndexesFromTableWithSelectedValues(const QString& tableName, const ColumnValueData& selectedValues, const IndexSet& previousSelection) const {

		QString queryString = "SELECT \"" + IndexColumnName + "\" FROM \"" + tableName + "\" WHERE ";

		ColumnValueData::const_iterator iT = selectedValues.begin();
		queryString += CreateInString(iT->first, iT->second);
		++iT;
		while (iT != selectedValues.end()) {

			queryString += " AND " + CreateInString(iT->first, iT->second);
			++iT;
		}

		if (!previousSelection.empty()) {

			queryString += " AND " + CreateInString(previousSelection);
		}

		QSqlQuery query(m_db);
		query.prepare(queryString);
		query.exec();
		if (!query.exec()) {

			throw std::exception((QObject::tr("Failed to get selected indexes from cache: ") + m_db.lastError().text()).toStdString().c_str());
		}

		unsigned long startingValue = GetStartingValueForTable(tableName);

		IndexSet indexSet;
		while (query.next()) {

			indexSet.insert(startingValue + query.value(0).toULongLong() - 1);
		}

		return indexSet;
	}

	SourceDataCache::DistinctValueIndexMap SourceDataCache::GetIndexesOrderedByDistinctValue(const QString& tableName, const QString& columnName) const {

		DistinctValueIndexMap distinctValueIndexMap;

		QString queryString = "SELECT \"" + columnName + "\", \"" + IndexColumnName + "\" FROM \"" + tableName + "\" ORDER BY \"" + columnName + "\" ASC";
		QSqlQuery query(m_db);
		query.prepare(queryString);
		query.exec();
		if (!query.exec()) {

			throw std::exception((QObject::tr("Failed to get ordered indexes: ") + m_db.lastError().text()).toStdString().c_str());
		}

		unsigned long startingValue = GetStartingValueForTable(tableName);

		QString previousDistinctValue(QString::null);
		while (query.next()) {

			QString currentDistinctValue = query.value(0).toString();
			if (currentDistinctValue != previousDistinctValue) {

				previousDistinctValue = currentDistinctValue;
				distinctValueIndexMap.push_back({ currentDistinctValue, IndexSet() });
			}

			distinctValueIndexMap.rbegin()->second.insert(startingValue + query.value(1).toULongLong() - 1);
		}
		query.finish();

		return distinctValueIndexMap;
	}

	bool SourceDataCache::IsCacheOutOfDate(const DatasourceMaps& datasources) const {

		if (!IsValid()) {

			throw std::exception("Source data cache is not setup.");
		}

		for (auto fileDatasource : datasources.GetFileDatasources()) {

			if (DoesFileDatasourceNeedUpdate(fileDatasource.first, fileDatasource.second)) {

				return true;
			}
		}

		return false;
	}

	bool SourceDataCache::DoesFileDatasourceNeedUpdate(const boost::uuids::uuid& id, const FileDatasource& datasource) const {

		if (!datasource.RequiresConversionToDB()) {

			return DoesFileDatabaseNeedUpdate(id, datasource);
		}
		else if (datasource.GetType() == FileDatasource::CSV) {

			QString tableName = QString::fromStdString(boost::uuids::to_string(id));
			QString csvFilename = QString::fromStdWString(datasource.GetFilename());
			return DoesCSVFileNeedUpdate(tableName, csvFilename, GetCSVTFilename(csvFilename));
		}
	}

	bool SourceDataCache::DoesFileDatabaseNeedUpdate(const boost::uuids::uuid& id, const FileDatasource& datasource) const {

		QString datasourceId = QString::fromStdString(boost::uuids::to_string(id));
		Datasource::TableSet tablesInCache;
		for (auto cacheTable : m_tableIndexMap) {

			if (cacheTable.right.startsWith(datasourceId)) {

				const QString& tableName = cacheTable.right;
				tablesInCache.insert(tableName.mid(tableName.lastIndexOf(':') + 1).toStdWString());
			}
		}

		if (tablesInCache.empty()) {

			return true;
		} else {

			QDateTime lastModifiedInCache = GetTimestampForTable(CreateTablename(datasourceId, QString::fromStdWString(*tablesInCache.begin())));
			QFileInfo datasourceFileInfo(QString::fromStdWString(datasource.GetFilename()));

			if ((tablesInCache != datasource.GetTables()) || (datasourceFileInfo.lastModified().toUTC() > lastModifiedInCache)) {

				return true;
			}
		}

		return false;
	}

} //namespace SynGlyphX
