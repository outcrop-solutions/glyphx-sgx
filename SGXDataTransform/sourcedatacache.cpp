#include "sourcedatacache.h"
#include <QtSql/QSqlRecord>
#include <QtSql/QSqlQuery>
#include <boost/uuid/uuid_io.hpp>

namespace SynGlyphX {

	const QString SourceDataCache::IndexColumnName = "Index";

	SourceDataCache::SourceDataCache(const QString& filename)
	{
		m_db = QSqlDatabase::addDatabase("QSQLITE", "source_cache_db");
		m_db.setDatabaseName(filename);
		
		if (!m_db.open()) {

			throw std::exception("Source data cache db failed to open.");
		}

		CreateTableMap();
	}

	SourceDataCache::SourceDataCache(const DatasourceMaps& datasources, const QString& filename)
	{
		m_db = QSqlDatabase::addDatabase("QSQLITE", "source_cache_db");
		m_db.setDatabaseName(filename);

		if (!m_db.open()) {

			throw std::exception("Source data cache db failed to open.");
		}

		for (auto fileDatasource : datasources.GetFileDatasources()) {

			AddFileDatasourceToCache(fileDatasource.first, fileDatasource.second);
		}

		if (!m_db.commit()) {

			throw std::exception("Source data cache db failed to commit source data.");
		}
	}

	SourceDataCache::~SourceDataCache()
	{
		QSqlDatabase::removeDatabase("source_cache_db");
	}

	void SourceDataCache::AddFileDatasourceToCache(const boost::uuids::uuid& id, const FileDatasource& datasource) {

		bool closeDatasource = false;
		QString dbConnectionID = QString::fromStdWString(boost::uuids::to_wstring(id));
		QSqlDatabase db;
		
		if (QSqlDatabase::contains(dbConnectionID)) {

			db = QSqlDatabase::database(dbConnectionID);
		}
		else {

			db = QSqlDatabase::addDatabase("QSQLITE", dbConnectionID);
			closeDatasource = true;
		}
		
		for (const std::wstring& table : datasource.GetTables()) {

			AddTableToCache(db, QString::fromStdWString(table));
		}

		if (closeDatasource) {

			QSqlDatabase::removeDatabase(dbConnectionID);
		}
	}

	void SourceDataCache::AddTableToCache(QSqlDatabase& db, const QString& table) {

		QSqlQuery createTableQuery;
		createTableQuery.prepare("");
	}

	SourceDataCache::TableMap SourceDataCache::GetTables() const {

		return m_tables;
	}

	QStringList SourceDataCache::GetColumnsForTable(const QString& table) const {

		QStringList columnNames;
		QSqlRecord columns = m_db.record(table);
		for (int i = 0; i < columns.count(); ++i) {

			QString fieldName = columns.fieldName(i);
			if (fieldName != IndexColumnName) {

				columnNames.push_back(fieldName);
			}
		}

		if (columnNames.isEmpty()) {

			throw std::invalid_argument("Source Data Cache was asked for column names for a table that does not exist");
		}

		return columnNames;
	}

	/*QVariantList SourceDataCache::GetDataAtIndex(unsigned long index) const {


	}*/

	void SourceDataCache::CreateTableMap() {

		QStringList unorderedTables = SourceDataManager::GetListOfTablesWithoutAutogeneratedTables(m_db);

		QSqlQuery query(m_db);
		QString queryTemplate = "SELECT " + IndexColumnName + " FROM %1 ORDER BY " + IndexColumnName + " DESC LIMIT 1";
		Q_FOREACH(QString table, unorderedTables) {

			query.prepare(queryTemplate.arg(table));
			query.exec();
			query.first();

			m_tables[query.value(0).toUlong()] = table;
		}
	}

} //namespace SynGlyphX
