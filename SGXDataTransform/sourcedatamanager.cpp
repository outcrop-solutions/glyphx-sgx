#include "sourcedatamanager.h"
#include <QtCore/QUuid>
#include <QtCore/QFile>
#include <QtCore/QFileInfo>
#include <QtCore/QVariant>
#include <exception>
#include <boost/uuid/uuid_io.hpp>
#include "datatransformmapping.h"
#include <QtSql/QSqlQuery>
#include "sqlcsvdriver.hpp"

namespace SynGlyphX {

	SourceDataManager::SourceDataManager()
	{
	}


	SourceDataManager::~SourceDataManager()
	{
	}

	void SourceDataManager::RegisterCustomDrivers() {

		QSqlDatabase::registerSqlDriver("CSV", new QSqlDriverCreator<CSVDriver>);
	}

	bool SourceDataManager::IsSQLiteDB(const QString& filename) {

		const char* first16BytesOfSQLiteDB = "SQLite format 3";

		QFile file(filename);
		if (file.exists()) {

			if (file.open(QIODevice::ReadOnly)) {

				uchar* first16bytes = file.map(0, 16);
				file.close();

				return (memcmp(first16bytes, first16BytesOfSQLiteDB, 16) == 0);
			}
		}

		return false;
	}

	QString SourceDataManager::GetFormattedDBName(const QSqlDatabase& db) {

		QString databaseName = db.databaseName();

		if (db.driverName() == "QSQLITE") {
			QFileInfo fi(databaseName);
			return fi.baseName();
		}
		else {
			return databaseName;
		}
	}

	QString SourceDataManager::GetFormattedDBName(const boost::uuids::uuid& databaseID) {

		QSqlDatabase db = QSqlDatabase::database(QString::fromStdString(boost::uuids::to_string(databaseID)));
		return GetFormattedDBName(db);
	}

	QStringList SourceDataManager::GetListOfTablesWithoutAutogeneratedTables(const QSqlDatabase& db) {

		QStringList tableList = db.tables();

		if (db.driverName() == "QSQLITE") {

			tableList.removeAll("sqlite_sequence");
		}

		return tableList;
	}

	QStringList SourceDataManager::GetListOfTablesWithoutAutogeneratedTablesInDatabaseFile(const QString& dbName) {

		QStringList tables;
		if (IsSQLiteDB(dbName)) {

			QSqlDatabase newDataSourceDB = QSqlDatabase::addDatabase("QSQLITE", "TEMPDB");
			newDataSourceDB.setDatabaseName(dbName);

			tables = GetListOfTablesWithoutAutogeneratedTables(newDataSourceDB);

			QSqlDatabase::removeDatabase("TEMPDB");
		}

		return tables;
	}

	QString SourceDataManager::GetQtDBType(const SynGlyphX::Datasource& datasource) {

		if (datasource.IsFile()) {

			const FileDatasource& fileDatasource = dynamic_cast<const FileDatasource&>(datasource);
			if (fileDatasource.GetType() == FileDatasource::SourceType::SQLITE3) {
			
				return "QSQLITE";
			}
			else if (fileDatasource.GetType() == FileDatasource::SourceType::CSV) {
				
				return "CSV";
			}
		}

		return "";
	}

	void SourceDataManager::AddDatabaseConnection(const Datasource& datasource, const boost::uuids::uuid& datasourceID) {

		QString datasourceName = QString::fromStdWString(datasource.GetDBName());

		QSqlDatabase newDataSourceDB = QSqlDatabase::addDatabase(GetQtDBType(datasource), QString::fromStdString(boost::uuids::to_string(datasourceID)));
		newDataSourceDB.setDatabaseName(datasourceName);
	}

	void SourceDataManager::AddDatabaseConnections(const DatasourceMaps& datasources) {

		for (auto fileDatasource : datasources.GetFileDatasources()) {

			AddDatabaseConnection(fileDatasource.second, fileDatasource.first);
		}
	}

	void SourceDataManager::ClearDatabaseConnections(const DatasourceMaps& datasources) {

		for (auto fileDatasource : datasources.GetFileDatasources()) {

			QSqlDatabase::removeDatabase(QString::fromStdString(boost::uuids::to_string(fileDatasource.first)));
		}
	}

	QVariantList SourceDataManager::RunSqlQuery(const InputField& inputfield) {

		QVariantList results;
		QSqlDatabase db = QSqlDatabase::database(QString::fromStdWString(boost::uuids::to_wstring(inputfield.GetDatasourceID())));

		QSqlQuery query(db);
		query.prepare(QString("SELECT %1 FROM ").arg("\"" + QString::fromStdWString(inputfield.GetField()) + "\"") + QString::fromStdWString(inputfield.GetTable()));
		query.exec();
		while (query.next()) {
			results.push_back(query.value(0));
		}

		return results;
	}

} //namespace SynGlyphX